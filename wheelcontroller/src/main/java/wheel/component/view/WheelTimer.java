/* * Copyright (C) 2010 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package wheel.component.view;import android.content.Context;import android.content.res.TypedArray;import android.util.AttributeSet;import android.view.LayoutInflater;import android.widget.LinearLayout;import kankan.wheel.widget.OnWheelChangedListener;import kankan.wheel.widget.OnWheelScrollListener;import kankan.wheel.widget.WheelView;import mma.mtake.wheel.component.R;import wheel.component.genview.GenWheelText;import wheel.component.genview.WheelGeneralAdapter;import wheel.component.utils.PreciseTimer;import wheel.component.utils.PreciseTimer.PreciseTimerListener;/** *Whenever you trigger the mechanism of "Count Down" ,it will be controlled by the  {@link #PreciseTimer}.</br> *Therefore, you should be pay attention to Whatever Thread you use to creating this Competent has to be UI Thread.</br> *As the same rule, whenever you set up the Timer through  {@link #WheelTimer.setTimer(long second)}.</br> *You also have to invoke this method through UI Thread carefully. * *</br></br> *創造本元件的執行序，與建立setTimer 的執行續，必續為UI Thread. *呼叫setTimer 的方法，也必須是UI Thread. * * @author JosephWang * */public class WheelTimer extends LinearLayout {	public static final String TAG = WheelTimer.class.getSimpleName();	private Context ctx;	private WheelView hourWheel;	private WheelView minuteWheel;	private WheelView secondWheel;	private String[] hourArray = new String[24];	private String[] minuteArray = new String[60];	private String[] secondArray = new String[60];	private GenWheelText genView = new GenWheelText(1, 22);	private TimeMode timeMode = TimeMode.SELECT;	private CountDownTimeMode countDownTimeMode = CountDownTimeMode.Begin;	public CountDownTimeMode getCountDownTimeMode() {		return countDownTimeMode;	}	public TimeMode getTimeMode() {		return timeMode;	}	public void setTimeMode(TimeMode timeMode) {		this.timeMode = timeMode;	}	private String hourText = "";	private TimeData timeData = new TimeData();	public TimeData getTimeData() {		return timeData;	}	public String getHourText() {		return hourText;	}	private String minuteText = "";	public String getMinuteText() {		return minuteText;	}	private String secondText = "";	public String getSecondText() {		return secondText;	}	private boolean isScrollFinish = true;	public boolean isScrollFinish() {		return isScrollFinish;	}	public WheelTimer(Context context) {		super(context);		ctx = context;		initData();		initStyle(null);		initDatePicker();	}	public WheelTimer(Context context, AttributeSet attrs) {		super(context, attrs);		ctx = context;		initData();		initStyle(attrs);		initDatePicker();	}	private void initStyle(AttributeSet attrs) {		int[] linerarLayoutAttrs = { android.R.attr.orientation };		TypedArray array = ctx.obtainStyledAttributes(attrs, linerarLayoutAttrs);		array.recycle();		array = ctx.obtainStyledAttributes(attrs, R.styleable.WheelTimerStyle);		timeMode = TimeMode.getStatus(array.getInt(R.styleable.WheelTimerStyle_timeMode, TimeMode.SELECT.ordinal()));		array.recycle();	}	private void initData() {		for (int index = 0; index < 24; index++) {			hourArray[index] = addZeroIfSmallThenTen(index);		}		for (int index = 0; index < 60; index++) {			minuteArray[index] = addZeroIfSmallThenTen(index);			secondArray[index] = addZeroIfSmallThenTen(index);		}	}	private String addZeroIfSmallThenTen(int res) {		StringBuffer result = new StringBuffer();		if (res < 10) {			result.append("0").append(String.valueOf(res));		} else {			result.append(res);		}		return result.toString();	}	private void sendSelectTime() {		if (selectListener != null) {			selectListener.handleTime(getCurrectTimeData());		}	}	private void sendCountDownData() {		if (countDownListener != null) {			countDownListener.handleTime(countDownTimeMode, getCurrectTimeData());		}	}	/**	 * 	 * @param layout	 * @param wheel	 * @param title	 * @param show	 * @param handler	 * @return {@link WheelView}	 */	public void initDatePicker() {		LinearLayout wheel = (LinearLayout) LayoutInflater.from(ctx).inflate(R.layout.wheel_timer, this, true);		hourWheel = (WheelView) wheel.findViewById(R.id.hour);		minuteWheel = (WheelView) wheel.findViewById(R.id.minute);		secondWheel = (WheelView) wheel.findViewById(R.id.second);		hourWheel.setCyclic(true);		minuteWheel.setCyclic(true);		secondWheel.setCyclic(true);		hourWheel.setVisibleItems(3);		minuteWheel.setVisibleItems(3);		secondWheel.setVisibleItems(3);		setWheelListener(hourWheel, hourArray);		setWheelListener(minuteWheel, minuteArray);		setWheelListener(secondWheel, secondArray);		hourWheel.addScrollingListener(scrollListener);		minuteWheel.addScrollingListener(scrollListener);		secondWheel.addScrollingListener(scrollListener);		hourWheel.setCurrentItem(0, true);		minuteWheel.setCurrentItem(0, true);		secondWheel.setCurrentItem(0, true);		enableWheelByTimeMode();	}	private void enableWheelByTimeMode() {		switch (timeMode) {		case SELECT:			setWheelEnable(true);			break;		case COUNTDOWN:			setWheelEnable(false);			break;		}	}	private void setWheelEnable(boolean enabled) {		hourWheel.setEnabled(enabled);		hourWheel.setFocusableInTouchMode(enabled);		minuteWheel.setEnabled(enabled);		minuteWheel.setFocusableInTouchMode(enabled);		secondWheel.setEnabled(enabled);		secondWheel.setFocusableInTouchMode(enabled);	}	private void setWheelListener(WheelView wheelView, String[] data) {		WheelGeneralAdapter viewAdapter = new WheelGeneralAdapter(ctx, genView);		viewAdapter.setData(data);		wheelView.setViewAdapter(viewAdapter);		wheelView.addChangingListener(changedListener);	}	private OnWheelChangedListener changedListener = new OnWheelChangedListener() {		@Override		public void onChanged(WheelView wheel, int oldValue, int newValue) {			if (wheel.getId() == R.id.hour) {				hourText = hourArray[newValue];			} else if (wheel.getId() == R.id.minute) {				minuteText = minuteArray[newValue];			} else if (wheel.getId() == R.id.second) {				secondText = secondArray[newValue];			}		}	};	private PreciseTimerListener timerListener = new PreciseTimerListener() {		@Override		public void timeout() {			countDownTimeMode = CountDownTimeMode.TimeOut;			hourWheel.setCurrentItem(0, true);			minuteWheel.setCurrentItem(0, true);			secondWheel.setCurrentItem(0, true);			sendCountDownData();		}		@Override		public void onTick(long tickSecond) {			countDownTimeMode = CountDownTimeMode.OnTick;			hourWheel.setCurrentItem(getHourIndexByTime(tickSecond), true);			minuteWheel.setCurrentItem(getMinuteIndexByTime(tickSecond), true);			secondWheel.setCurrentItem(getSecondIndexByTime(tickSecond), true);			sendCountDownData();		}		@Override		public void onStart(long tickSecond) {			countDownTimeMode = CountDownTimeMode.Begin;			hourWheel.setCurrentItem(getHourIndexByTime(tickSecond), false);			minuteWheel.setCurrentItem(getMinuteIndexByTime(tickSecond), false);			secondWheel.setCurrentItem(getSecondIndexByTime(tickSecond), false);			sendCountDownData();		}	};	public int getSecondIndexByTime(long tickSecond) {		int indexInSecond = (int) (tickSecond % (60 * 60));		indexInSecond = indexInSecond % 60;		return indexInSecond;	}	public void setTimer(long second) {		int hourIndex = getHourIndexByTime(second);		int minuteIndex = getMinuteIndexByTime(second);		int secondIndex = getSecondIndexByTime(second);		setTimer(hourIndex, minuteIndex, secondIndex);	}	private int getHourIndexByTime(long tickSecond) {		int index = (int) tickSecond / 60 / 60;		return index;	}	private int getMinuteIndexByTime(long tickSecond) {		int index = (int) tickSecond / 60;		return index;	}	private PreciseTimer timer;	public void setTimer(int hour, int minute, int second) {		long secondInHour = hour * 60 * 60;		long secondInMinute = minute * 60;		long totalSecond = secondInHour + secondInMinute + second;		if (hour < 24) {			hourWheel.setCurrentItem((int) hour, false);		}		if (minute < 60 && second < 60) {			minuteWheel.setCurrentItem((int) minute, false);			secondWheel.setCurrentItem((int) second, false);		}		timeMode = TimeMode.COUNTDOWN;		enableWheelByTimeMode();		timer = new PreciseTimer(timerListener, totalSecond);		timer.start();	}	/**	 * Stop timer.</br> 停止Timer.	 */	public void stopTimer() {		if (timer != null) {			countDownTimeMode = CountDownTimeMode.Stop;			timer.stop();		}	}	/**	 * Pause timer,and record the tick second.</br> 暫停Timer 並記錄時間.	 */	public void pauseTimer() {		if (timer != null) {			countDownTimeMode = CountDownTimeMode.Pause;			timer.pause();		}	}	/**	 * Resume timer with the record time paused before.</br> 以上次暫停記錄時間,恢復Timer.	 */	public void resumeTimer() {		if (timer != null) {			countDownTimeMode = CountDownTimeMode.Resume;			timer.resume();		}	}	/**	 * ReStart timer with the begin time.</br> 重啟Timer.	 */	public void reStart() {		if (timer != null) {			countDownTimeMode = CountDownTimeMode.ReStart;			timer.reStart();		}	}	private OnWheelScrollListener scrollListener = new OnWheelScrollListener() {		@Override		public void onScrollingStarted(WheelView wheel) {			isScrollFinish = false;		}		@Override		public void onScrollingFinished(WheelView wheel) {			isScrollFinish = true;			if (isScrollFinish) {				sendSelectTime();			}		}	};	private TimeData getCurrectTimeData() {		hourText = hourArray[hourWheel.getCurrentItem()];		minuteText = minuteArray[minuteWheel.getCurrentItem()];		secondText = secondArray[secondWheel.getCurrentItem()];		timeData.hour = hourWheel.getCurrentItem();		timeData.minute = minuteWheel.getCurrentItem();		timeData.second = secondWheel.getCurrentItem();		timeData.hourText = hourText;		timeData.minuteText = minuteText;		timeData.secondText = secondText;		return timeData;	}	private WheelTimerCountDownListener countDownListener;	public void setWheeCountDownlListener(WheelTimerCountDownListener wheelListener) {		this.countDownListener = wheelListener;	}	public static interface WheelTimerCountDownListener {		public void handleTime(CountDownTimeMode status, TimeData timeData);	}	private WheelTimerSelectListener selectListener;	public void setWheeSelectlListener(WheelTimerSelectListener wheelListener) {		this.selectListener = wheelListener;	}	public static interface WheelTimerSelectListener {		public void handleTime(TimeData timeData);	}	public static class TimeData {		/**		 * 實際的時間		 */		public int hour = 0;		public int minute = 0;		public int second = 0;		/**		 * 顯示用的時間		 */		public String hourText = "";		public String minuteText = "";		public String secondText = "";	}	/**	 * The way to use Timer.	 * 	 * 使用Timer 的方式	 * 	 * @author JosephWang	 * 	 */	public static enum TimeMode {		SELECT, COUNTDOWN;		public static TimeMode getStatus(int index) {			return TimeMode.values()[index];		}	}}