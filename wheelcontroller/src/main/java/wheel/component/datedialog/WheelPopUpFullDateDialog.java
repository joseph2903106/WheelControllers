/* * Copyright (C) 2010 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package wheel.component.datedialog;import android.content.Context;import android.graphics.drawable.ColorDrawable;import android.os.Message;import android.view.Display;import android.view.KeyEvent;import android.view.LayoutInflater;import android.view.MotionEvent;import android.view.View;import android.view.View.OnKeyListener;import android.view.View.OnTouchListener;import android.view.ViewGroup;import android.view.WindowManager;import android.widget.PopupWindow;import android.widget.TextView;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;import mma.mtake.wheel.component.R;import wheel.component.controller.OnShowWheelListener;import wheel.component.utils.UIAdjuster;import wheel.component.view.TriangleView;import wheel.component.view.WheelControlListener;import wheel.component.view.WheelFullDatePicker;import wheel.component.view.WheelFullDatePicker.WheelFullDateSyncListener;/****** * *Be careful!!!. Depends on the Android internal policy,</br> you can not * leave PopupWindow open while Activity is being finished.You have to close * this PopupWindow before Activity to be finished.Otherwise, the only * consequences you will receive that Application is terminated</br></br> *  * PopupWindow 一定要在 Acitivty 被finish之前關起來，不然程式會crash *  * <pre class="prettyprint"> * 使用範例 * 		WheelPopUpDateDialog dialog = new WheelPopUpDateDialog(this, listener); *  * 		dialog.setShowTaiwanYear(true); * 		dialog.setCanSetUpFutureTime(true); * 		dialog.setCanSetUpPastTime(true); * 		dialog.setCanRestrictBetweenDate(true); * 		dialog.setRestrictDate(beforeDate(), afterDate()); * 		dialog.setWheelListener(findViewById(R.id.test_left), "I am popUp"); *  *  * 	public Calendar beforeDate() { * 		Calendar want = Calendar.getInstance(); * 		want.add(Calendar.MONTH, -2); * 		want.set(Calendar.DAY_OF_MONTH, 15);// 下個月月底 * 		return want; * 	} *  * 	public Calendar afterDate() { * 		Calendar want = Calendar.getInstance(); * 		want.add(Calendar.MONTH, 2); * 		want.set(Calendar.DAY_OF_MONTH, 15);// 下個月月底// 下個月月底 * 		return want; * 	} *  * 	private WheelControlListener listener = new WheelControlListener() { * 		@Override * 		public void handleClick(int viewId, Object obj) { * 			editor.setText(WheelPopUpDateDialog.showCalendarText((Calendar) obj)); * 		} * 	}; * </pre> *  * @author JosephWang *  */public class WheelPopUpFullDateDialog implements OnKeyListener {	public static final String TAG = WheelPopUpFullDateDialog.class.getSimpleName();	/**************** 滾輪選到的時間物件 ***************************/	private Calendar currentCalendar = Calendar.getInstance();	/**************** 使用者最後確定按鈕選到的時間物件 ***************************/	private Calendar clickCalendar = Calendar.getInstance();	private Message wheelMsg = new Message();	private WheelControlListener<Calendar> controllerListenr;	private Context act;	private WheelFullDatePicker date_picker;	private PopupWindow popWindow;// 提示視窗的	private ViewGroup wheel;	private static String[] weekForDisplay;	private int[] archorViewLocation = new int[2];	private String year;	private String month;	private String date;	private int dialogWidth = 300;	public int getDialogWidth() {		return dialogWidth;	}	public void setDialogWidth(int dialogWidth) {		this.dialogWidth = dialogWidth;	}	private int dialogHeight = 280;	public int getDialogHeight() {		return dialogHeight;	}	public void setDialogHeight(int dialogHeight) {		this.dialogHeight = dialogHeight;	}	private int moveCenterX;	private int moveCenterY;	private int popWindowPositionX = 0;	private int popWindowPositionY = 0;	private int deviceWidth = 0;	private int deviceHeight = 0;	private Calendar beforeDate;	public Calendar getBeforeDate() {		return beforeDate;	}	private boolean setRestrictBetweenDate = false;	public boolean isSetRestrictBetweenDate() {		return setRestrictBetweenDate;	}	/*****	 * Only as Setting this attribute that letting the mechanism to be	 * trigger.false to be disable.	 * 	 * @return boolean</br> 只有設定此屬性，為"true" 能啟動時間限制機制，為"false" 關閉.	 */	public void setCanRestrictBetweenDate(boolean setRestrictBetweenDate) {		this.setRestrictBetweenDate = setRestrictBetweenDate;	}	/***	 * As the semantics in method.You can restrict ceiling and flooring in the	 * period of</br> available time in WheelFullDatePicker.Whenever you want to	 * set WheelFullDatePicker be restricted or not, you can trigger it through	 * {@link #WheelFullDatePicker.setCanRestrictBetweenDate(boolean setRestrictBetweenDate)}	 * .Therefore,only under those condition that</br> 1,	 * isSetRestrictBetweenDate() == true </br> 2, beforeDate!= null </br> 3,	 * afterDate!= null,and this mechanism will be triggered.</br> Be careful	 * that not to set afterDate earlier than beforeDate!!</br> </br>	 * 	 * 限制滾輪時間選單的選取時間。 要達成限制條件,要先設定	 * {@link #setCanRestrictBetweenDate(boolean setRestrictBetweenDate)}	 * true.</br> 如果要取消限制條件	 * {@link #setCanRestrictBetweenDate(boolean setRestrictBetweenDate)}	 * false.</br> 並設定上下限時間	 * 	 * @param beforeDate	 * @param afterDate	 * @throws Exception	 */	public void setRestrictDate(Calendar beforeDate, Calendar afterDate) {		if (beforeDate.after(afterDate)) {			throw new IllegalArgumentException("This is weird that setting afterDate earlier than beforeDate!!! You must think more.");		} else {			this.beforeDate = beforeDate;			this.afterDate = afterDate;		}	}	private Calendar afterDate;	public Calendar getAfterDate() {		return afterDate;	}	/**	 * @return 使用者最後確定按鈕選到的時間物件	 */	public Calendar getClickCalendar() {		return clickCalendar;	}	/**	 * @return 滾輪選到的時間物件	 */	public Calendar getSelectCalendar() {		return currentCalendar;	}	public String getYear() {		return year;	}	private static boolean showTaiwanYear = false;	public boolean isShowTaiwanYear() {		return showTaiwanYear;	}	/******** 是否顯示民國年 *****/	public void setShowTaiwanYear(boolean isTaiwanYear) {		showTaiwanYear = isTaiwanYear;	}	private boolean canSetUpPastTime = true;	/******** 是否可以設定今天以前的時間 *****/	public boolean canSetUpPastTime() {		return canSetUpPastTime;	}	/*****	 * Only as Setting this attribute that can user restrict the period of time	 * to be earlier than today as "true",</br> and whenever user select as	 * "false".	 * 	 * @return boolean 只有設定此屬性，為"true" 能限制使用者設定早於今天，為"false" 無限制.	 */	public void setCanSetUpPastTime(boolean canSetUpPastTime) {		this.canSetUpPastTime = canSetUpPastTime;	}	private boolean canSetUpFutureTime = true;	/******** 是否可以設定今天以後的時間 *****/	public boolean canSetUpFutureTime() {		return canSetUpFutureTime;	}	private boolean currentTimeVisible = false;	public boolean isCurrentTimeVisible() {		return currentTimeVisible;	}	/**	 * 是否及時顯示選取時間	 * 	 * @param currentTimeVisible	 */	public void setCurrentTimeVisible(boolean currentTimeVisible) {		this.currentTimeVisible = currentTimeVisible;	}	/*****	 * Only as Setting this attribute that can user restrict the period of time	 * to be laster than today as "true",</br> and whenever user select as	 * "false".	 * 	 * @return boolean 只有設定此屬性，為"true" 能限制使用者設定晚於今天，為"false" 無限制.	 */	public void setCanSetUpFutureTime(boolean canSetUpFutureTime) {		this.canSetUpFutureTime = canSetUpFutureTime;	}	public String getChineseYear() {		if (year != null && !year.equals("")) {			String result = "";			try {				result = "" + (Integer.parseInt(year) - 1911);			} catch (Exception e) {				e.printStackTrace();			}			return result;		} else {			return "";		}	}	public String getMonth() {		return month;	}	public String getDate() {		return date;	}	public String getChineseRequestDate() {		StringBuffer result = new StringBuffer();		result.append(getChineseYear());		result.append(addZeroIfSmallThenTen(getMonth()));		result.append(addZeroIfSmallThenTen(getDate()));		return result.toString();	}	public String getRequestDate() {		StringBuffer result = new StringBuffer();		result.append(getYear());		result.append(addZeroIfSmallThenTen(getMonth()));		result.append(addZeroIfSmallThenTen(getDate()));		return result.toString();	}	private String addZeroIfSmallThenTen(String res) {		String result = "";		if (Integer.parseInt(res) < 10) {			result = "0" + res;		} else {			result = res;		}		return result;	}	public WheelPopUpFullDateDialog(Context act, WheelControlListener<Calendar> controllerListenr) {		this.act = act;		this.controllerListenr = controllerListenr;		initWheel();		initPopWindow();		weekForDisplay = act.getResources().getStringArray(R.array.week_in_calendar);	}	/******	 * Setting the callBack of "WheelListener" with each each	 * View,independently.Theorefore, API user can control the callback through	 * "WheelControlListener" with the clue of View's Id.	 * 	 * 對每個View 設定獨立的WheelListener.如此一來，使用者可以藉由"WheelControlListener" 依據不同的View	 * id 控制所有的滾輪行為.	 * 	 * @param eachView	 * @param title	 * */	public void setWheelListener(View eachView, String title) {		eachView.setOnClickListener(getWheelClickListener(title));	}	private View.OnClickListener getWheelClickListener(final String title) {		return new View.OnClickListener() {			@Override			public void onClick(View v) {				UIAdjuster.closeKeyBoard(act);				if (showWheelListener.showWheel(v)) {					wheelMsg.what = v.getId();					wheelMsg.obj = currentCalendar;					showDatePicker(v, title);				}			}		};	}	private OnShowWheelListener showWheelListener = new OnShowWheelListener() {		@Override		public boolean showWheel(View v) {			return true;		}	};	public OnShowWheelListener getOnShowWheelListener() {		return showWheelListener;	}	/**	 * 增加直接設定 OnShowWheelListener	 * 	 * @param showWheelListener	 */	public void setOnShowWheelListener(OnShowWheelListener showWheelListener) {		this.showWheelListener = showWheelListener;	}	/**	 * 顯示日期加星期	 * 	 * @param calendar	 * @return	 */	public static String dateFormatWithWeek(Calendar calendar) {		return showCalendarText(calendar) + " " + getDayName(calendar.get(Calendar.DAY_OF_WEEK));	}	/**	 * 顯示日期	 * 	 * @param calendar	 * @return	 */	public static String showCalendarText(Calendar calendar) {		StringBuffer sb = new StringBuffer();		if (showTaiwanYear) {			sb.append(calendar.get(Calendar.YEAR) - 1911).append("/").append(calendar.get(Calendar.MONTH) + 1).append("/").append(calendar.get(Calendar.DAY_OF_MONTH));		} else {			SimpleDateFormat format = new SimpleDateFormat("yyyy/MM/dd");			sb.append(format.format(new Date(calendar.getTimeInMillis())));		}		return sb.toString();	}	public static String getDayName(int day) {		return weekForDisplay[day - 1];	}	private void initWheelFullDatePickerStyle() {		/****************** 初始化WheelFullDatePicker *************************/		date_picker = (WheelFullDatePicker) wheel.findViewById(R.id.date_picker);		date_picker.setCanSetUpPastTime(canSetUpPastTime());		date_picker.setCanSetUpFutureTime(canSetUpFutureTime());		date_picker.setSetCurrentTimeVisible(isCurrentTimeVisible());		date_picker.setShowTaiwanYear(isShowTaiwanYear());		date_picker.setWheelListener(date_picker.getId(), wheelListener);		date_picker.setToday();		date_picker.setCanRestrictBetweenDate(setRestrictBetweenDate);		/****************** 初始化WheelFullDatePicker *************************/	}	private boolean isTouchOutSideCancelable = true;	public boolean isTouchOutSideCancelable() {		return isTouchOutSideCancelable;	}	public void setTouchOutSideCancelable(boolean isTouchOutSideCancelable) {		this.isTouchOutSideCancelable = isTouchOutSideCancelable;	}	private void initPopWindow() {		if (popWindow == null) {			popWindow = new PopupWindow(wheel, (int) UIAdjuster.computeDIPtoPixel(act, getDialogWidth()), (int) UIAdjuster.computeDIPtoPixel(act, getDialogHeight()));			popWindow.setAnimationStyle(R.style.PopupArchorAnimation);			// popWindow.setBackgroundDrawable(null);//			// let_Animation_to_be_smooth!!!			/*** let_OutsideTouchable_to_be_work_for_closing_PopUpWindow!! *****/			popWindow.setBackgroundDrawable(new ColorDrawable(android.R.color.transparent));//			/*** let_OutsideTouchable_to_be_work_for_closing_PopUpWindow!! *****/			popWindow.setTouchable(true);			popWindow.setFocusable(true);			popWindow.setClippingEnabled(false);			popWindow.setOutsideTouchable(true);			popWindow.setTouchInterceptor(new OnTouchListener() {				@Override				public boolean onTouch(View v, MotionEvent event) {					switch (event.getAction()) {					case MotionEvent.ACTION_OUTSIDE:						if (isTouchOutSideCancelable()) {							dismiss();							return true;						} else {							return false;						}					}					return false;				}			});		}		if (isCurrentTimeVisible()) {			setDialogHeight(280);			popWindow.setHeight((int) UIAdjuster.computeDIPtoPixel(act, getDialogHeight()));		}	}	private void initPeriodRestrict() {		if (beforeDate != null && afterDate != null) {			try {				setRestrictBetweenDate = true;				date_picker.setCanRestrictBetweenDate(setRestrictBetweenDate);				date_picker.setRestrictDate(beforeDate, afterDate);			} catch (Exception e) {				e.printStackTrace();			}		}	}	private TriangleView left_top_triangle;	private TriangleView center_top_triangle;	private TriangleView right_top_triangle;	private TriangleView left_bottom_triangle;	private TriangleView center_bottom_triangle;	private TriangleView right_bottom_triangle;	private void initWheel() {		wheel = (ViewGroup) LayoutInflater.from(act).inflate(R.layout.full_date_wheel_dialog_for_popup, null);		wheel.findViewById(R.id.ok).setOnClickListener(clickListener);		wheel.findViewById(R.id.cancel).setOnClickListener(clickListener);		left_top_triangle = (TriangleView) wheel.findViewById(R.id.left_top_triangle);		center_top_triangle = (TriangleView) wheel.findViewById(R.id.center_top_triangle);		right_top_triangle = (TriangleView) wheel.findViewById(R.id.right_top_triangle);		left_bottom_triangle = (TriangleView) wheel.findViewById(R.id.left_bottom_triangle);		center_bottom_triangle = (TriangleView) wheel.findViewById(R.id.center_bottom_triangle);		right_bottom_triangle = (TriangleView) wheel.findViewById(R.id.right_bottom_triangle);		initWheelFullDatePickerStyle();	}	@SuppressWarnings("deprecation")	public void showDatePicker(View anchor, String title) {		if (deviceHeight == 0 || deviceWidth == 0) {			Display display = ((WindowManager) act.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();			deviceHeight = display.getHeight();			deviceWidth = display.getWidth();		}		anchor.getLocationInWindow(archorViewLocation);		moveCenterX = archorViewLocation[0];		moveCenterY = archorViewLocation[1];		if (null != title) {			((TextView) popWindow.getContentView().findViewById(R.id.title)).setText(title);		}		initPeriodRestrict();		adjustPopUpPosition(anchor);		if (dialogListener != null) {			dialogListener.onShowWheel(wheelMsg.what, date_picker);		} else {			date_picker.setToday();		}	}	private OnShowWheelDialogListener dialogListener = new OnShowWheelDialogListener() {		@Override		public void onShowWheel(int viewId, WheelFullDatePicker picker) {			try {				picker.scrollToCertainDate(Calendar.getInstance());			} catch (Exception e) {				e.printStackTrace();			}		}	};	public OnShowWheelDialogListener getDialogListener() {		return dialogListener;	}	/**	 * 增加直接設定 OnShowWheelListener	 * 	 * @param showWheelListener	 */	public void setDialogListener(OnShowWheelDialogListener dialogListener) {		this.dialogListener = dialogListener;	}	/**	 * 調整視窗位置	 * **/	private void adjustPopUpPosition(View anchor) {		left_top_triangle.setVisibility(View.GONE);		center_top_triangle.setVisibility(View.GONE);		right_top_triangle.setVisibility(View.GONE);		left_bottom_triangle.setVisibility(View.GONE);		center_bottom_triangle.setVisibility(View.GONE);		right_bottom_triangle.setVisibility(View.GONE);		if (!popWindow.isShowing()) {			/****************** 使用者點擊View 右邊寬度不足於放PopUpWindow 的調整 ***************************/			if (Math.abs(deviceWidth - moveCenterX) < Math.abs(deviceWidth - (int) UIAdjuster.computeDIPtoPixel(act, getDialogWidth()))) {				popWindowPositionX = -(int) UIAdjuster.computeDIPtoPixel(act, getDialogWidth());			} else {				popWindowPositionX = 0;			}			if (Math.abs(deviceHeight - moveCenterY) < (int) UIAdjuster.computeDIPtoPixel(act, getDialogHeight())) {				popWindowPositionY = -(int) UIAdjuster.computeDIPtoPixel(act, getDialogHeight()) - anchor.getHeight() + (int) UIAdjuster.computeDIPtoPixel(act, 25) / 2;			} else {				popWindowPositionY = 0;			}			/****************** 使用者點擊在右下角 ***************************/			if (moveCenterX > deviceWidth / 2 && moveCenterY > deviceHeight / 2) {// 右下角				popWindowPositionX = -(int) UIAdjuster.computeDIPtoPixel(act, getDialogWidth()) + anchor.getWidth();				popWindowPositionY = -(int) UIAdjuster.computeDIPtoPixel(act, getDialogHeight()) - anchor.getHeight() + (int) UIAdjuster.computeDIPtoPixel(act, 25) / 2;				left_top_triangle.setVisibility(View.GONE);				center_top_triangle.setVisibility(View.GONE);				right_top_triangle.setVisibility(View.GONE);				left_bottom_triangle.setVisibility(View.GONE);				center_bottom_triangle.setVisibility(View.GONE);				right_bottom_triangle.setVisibility(View.VISIBLE);			}			/****************** 使用者點擊在左下角 ***************************/			else if (moveCenterX < deviceWidth / 2 && moveCenterY > deviceHeight / 2) {// 左下角				popWindowPositionX = 0;				popWindowPositionY = -(int) UIAdjuster.computeDIPtoPixel(act, getDialogHeight()) - anchor.getHeight() + (int) UIAdjuster.computeDIPtoPixel(act, 25) / 2;				left_top_triangle.setVisibility(View.GONE);				center_top_triangle.setVisibility(View.GONE);				right_top_triangle.setVisibility(View.GONE);				left_bottom_triangle.setVisibility(View.VISIBLE);				center_bottom_triangle.setVisibility(View.GONE);				right_bottom_triangle.setVisibility(View.GONE);			}			/****************** 使用者點擊在右上角 ***************************/			else if (moveCenterX > deviceWidth / 2 && moveCenterY < deviceHeight / 2) {// 右上角				popWindowPositionX = -(int) UIAdjuster.computeDIPtoPixel(act, getDialogWidth()) + anchor.getWidth();				popWindowPositionY = -(int) UIAdjuster.computeDIPtoPixel(act, 25) / 2;				left_top_triangle.setVisibility(View.GONE);				center_top_triangle.setVisibility(View.GONE);				right_top_triangle.setVisibility(View.VISIBLE);				left_bottom_triangle.setVisibility(View.GONE);				center_bottom_triangle.setVisibility(View.GONE);				right_bottom_triangle.setVisibility(View.GONE);			}			/****************** 使用者點擊在左上角 ***************************/			else if (moveCenterX < deviceWidth / 2 && moveCenterY < deviceHeight / 2) {// 左上角				popWindowPositionX = 0;				popWindowPositionY = -(int) UIAdjuster.computeDIPtoPixel(act, 25) / 2;				left_top_triangle.setVisibility(View.VISIBLE);				center_top_triangle.setVisibility(View.GONE);				right_top_triangle.setVisibility(View.GONE);				left_bottom_triangle.setVisibility(View.GONE);				center_bottom_triangle.setVisibility(View.GONE);				right_bottom_triangle.setVisibility(View.GONE);			} else {				left_top_triangle.setVisibility(View.GONE);				center_top_triangle.setVisibility(View.VISIBLE);				right_top_triangle.setVisibility(View.GONE);				left_bottom_triangle.setVisibility(View.GONE);				center_bottom_triangle.setVisibility(View.GONE);				right_bottom_triangle.setVisibility(View.GONE);			}			popWindow.showAsDropDown(anchor, popWindowPositionX, popWindowPositionY);			popWindowPositionX = 0;			popWindowPositionY = 0;		}	}	private View.OnClickListener clickListener = new View.OnClickListener() {		@Override		public void onClick(View v) {			if (v.getId() == R.id.ok) {				WheelFullDatePicker datePicker = (WheelFullDatePicker) popWindow.getContentView().findViewById(R.id.date_picker);				Calendar selectDate = datePicker.getSelectedTime();				if (!isSetRestrictBetweenDate()) {					if (!canSetUpPastTime() && 						selectDate.before(getTodayCalendar())) {						datePicker.setToday();						return;					} else if (!canSetUpFutureTime() && 							   selectDate.after(getTodayCalendar())) {						datePicker.setToday();						return;					}				}				if (datePicker.isScrollFinish()) {					clickCalendar = currentCalendar;					wheelMsg.obj = selectDate;					controllerListenr.handleClick(wheelMsg.what, (Calendar) wheelMsg.obj);					dismiss();				}			} else if (v.getId() == R.id.cancel) {				dismiss();			}		}	};	public void scrollToAfterDate() {		if (date_picker != null) {			date_picker.scrollToAfterDate();		}	}	public void scrollToBeforeDate() {		if (date_picker != null) {			date_picker.scrollToBeforeDate();		}	}	/**	 * Close the WheelPopUpDateDialog.</br> 關閉滾輪	 * **/	public void dismiss() {		if (popWindow != null) {			popWindow.dismiss();		}	}	public static Calendar getTodayCalendar() {		return Calendar.getInstance();	}	public static String getTodayString() {		String year = "" + Calendar.getInstance().get(Calendar.YEAR);		int month = (Calendar.getInstance().get(Calendar.MONTH) + 1);		String monthString = "";		if ((Calendar.getInstance().get(Calendar.MONTH) + 1) < 10) {			monthString = "0" + month;		}		String date = "" + Calendar.getInstance().get(Calendar.DAY_OF_MONTH);		return "" + year + monthString + date;	}	public static String getChinaTodayString() {		String year = String.valueOf(Calendar.getInstance().get(Calendar.YEAR) - 1911);		int month = (Calendar.getInstance().get(Calendar.MONTH) + 1);		String monthString = "";		if ((Calendar.getInstance().get(Calendar.MONTH) + 1) < 10) {			monthString = "0" + month;		}		String date = "" + Calendar.getInstance().get(Calendar.DAY_OF_MONTH);		return "" + year + monthString + date;	}	@Override	public boolean onKey(View v, int keyCode, KeyEvent event) {		dismiss();		return true;	}	private WheelFullDateSyncListener wheelListener = new WheelFullDateSyncListener() {		@Override		public void handleDate(int viewID, Calendar calendar) {			currentCalendar = calendar;			if (date_picker != null) {				year = "" + calendar.get(Calendar.YEAR);				month = "" + (calendar.get(Calendar.MONTH) + 1);				date = "" + calendar.get(Calendar.DATE);			}		}	};}